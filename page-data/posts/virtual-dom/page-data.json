{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/virtual-dom","result":{"data":{"markdownRemark":{"id":"3d4887a7-d555-599a-af62-9982c6509cdb","html":"<h3 id=\"virtual-dom\" style=\"position:relative;\"><a href=\"#virtual-dom\" aria-label=\"virtual dom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual DOM</h3>\n<p>Virtual DOM이란 뭔가?? 왜 사용하는가??   </p>\n<h4 id=\"브라우저-렌더링\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"브라우저 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 렌더링</h4>\n<p><a href=\"https://world-one.github.io/posts/browser-rendering,\" title=\"브라우저 렌더링 간단 정리\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Browser Rendering</a>   </p>\n<p>HTML으로부터 DOM Tree를 생성하고, CSS를 파싱하여 스타일 룰을 Attachment하여 Reder Tree를 생성한다.<br>\nreflow가 일어난다.( 각 노드의 위치 )<br>\npainting, 즉 각 노드에 색을 입힌다.</p>\n<h4 id=\"그럼-virtual-dom을-왜-쓰는가\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-virtual-dom%EC%9D%84-%EC%99%9C-%EC%93%B0%EB%8A%94%EA%B0%80\" aria-label=\"그럼 virtual dom을 왜 쓰는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그럼 Virtual DOM을 왜 쓰는가?</h4>\n<p>일반적으로 Vue, React와 같은 SPA는 DOM조작이 많이 일어난다.<br>\nreflow가 많이 일어나면 성능이 떨어진다. 비효율적이다.<br>\nVirtual DOM은 렌더링은 일어나지 않으며,<br>\n미리 가상의 DOM에 변화를 적용한 뒤 실제 DOM과 비교하여 변화된 부분만 적용한다.<br>\n브라우저가 하는 일을 줄여 성능을 개선시킨다고 한다.   </p>\n<p>그러니까 실제로 브라우저에 그려지는 부분을 제외하고<br>\n메모리에서 연산이 일어나고 최종적으로 변화한 부분만<br>\n화면에 그려준다는 말로 이해하면 되는 듯 싶다.</p>\n<p>여러번 변경되어야 할 것을 한번에 모아서 처리해준다.<br>\n이건 브라우저가 불필요하게 렌더링하는 것을 막아준다.</p>\n<h4 id=\"virtual-dom-구현\" style=\"position:relative;\"><a href=\"#virtual-dom-%EA%B5%AC%ED%98%84\" aria-label=\"virtual dom 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual DOM 구현?</h4>\n<p>DOM 요소를 객체로 표현하면</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{ type: &#39;ul&#39;, props: { &#39;class&#39;: &#39;list&#39; }, children: [\n  { type: &#39;li&#39;, props: {}, children: [&#39;item 1&#39;] },\n  { type: &#39;li&#39;, props: {}, children: [&#39;item 2&#39;] }\n] }</code></pre></div>\n<p>저기서 이제 각 노드들을 비교하여 바뀐 값만 업데이트 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function createElement(node: any) {\n  if (typeof node === &#39;string&#39;) {\n    return document.createTextNode(node);\n  }\n  const $el = document.createElement(node.type);\n  \n  node.children\n    .map(createElement)\n    .forEach($el.appendChild.bind($el));\n  return $el;\n}</code></pre></div>\n<p>실제 돔 노드를 반환</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function updateElement($parent: any, newNode: any, oldNode: any, index = 0) {\n  if (!oldNode) {\n    $parent.appendChild(\n      createElement(newNode)\n    );\n  } else if (!newNode) {\n    $parent.removeChild(\n      $parent.childNodes[index]\n    );\n  } else if (changed(newNode, oldNode)) { \n    $parent.replaceChild(\n      createElement(newNode),\n      $parent.childNodes[index]\n    );\n  } else if (newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    for (let i = 0; i &lt; newLength || i &lt; oldLength; i++) {\n      updateElement(\n        $parent.childNodes[index],\n        newNode.children[i],\n        oldNode.children[i],\n        i\n      );\n    }\n  }\n}</code></pre></div>\n<p>변경된 값을 찾아 업데이트</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function changed(node1: any, node2: any) {\n  return typeof node1 !== typeof node2 ||\n         typeof node1 === &#39;string&#39; &amp;&amp; node1 !== node2 ||\n         node1.type !== node2.type\n}</code></pre></div>\n<p>값이 변했는 확인   </p>\n<p>일단 참고 사이트의 예제를 그대로 써서 동작하는걸 확인했다.<br>\n가상 돔이라는게 특별한게 아니라, 실제 돔 형태를 내가 만들어서 직접 비교할 수 있게 하는 방식?? 이라는 생각이 든다.<br>\n기본 개념을 이해하는 건 이 정도면 충분할 것 같다.</p>\n<h4 id=\"참고사이트\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%82%AC%EC%9D%B4%ED%8A%B8\" aria-label=\"참고사이트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고사이트</h4>\n<p><a href=\"https://medium.com/@enro2414_40667/virtual-dom-%EB%B2%84%EC%B6%94%EC%96%BC-%EB%8F%94-%EA%B0%80%EC%83%81-%EB%8F%94-%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-1c44606ea9b1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@enro2414_40667/virtual-dom-%EB%B2%84%EC%B6%94%EC%96%BC-%EB%8F%94-%EA%B0%80%EC%83%81-%EB%8F%94-%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-1c44606ea9b1</a></p>\n<p><a href=\"https://www.holaxprogramming.com/2018/04/15/react-optimizing-virtual-dom-explained/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.holaxprogramming.com/2018/04/15/react-optimizing-virtual-dom-explained/</a></p>","fields":{"slug":"/posts/virtual-dom","tagSlugs":["/tag/virtual-dom/","/tag/javascript/"]},"frontmatter":{"date":"2020-07-03","description":"버추얼 돔이란 무엇인가??","tags":["virtual DOM","javascript"],"title":"Virtual DOM","socialImage":"/bg_work.jpg"}}},"pageContext":{"slug":"/posts/virtual-dom"}}}