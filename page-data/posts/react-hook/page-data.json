{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/react-hook","result":{"data":{"markdownRemark":{"id":"3e75e2f0-2d43-5c95-9f89-ca73fabb9a7d","html":"<h3 id=\"리액트-훅react-hook\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%9B%85react-hook\" aria-label=\"리액트 훅react hook permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트 훅(React Hook)</h3>\n<p>훅은 함수형 컴포넌트에 기능을 추가할 때 사용하는 함수다.\n함수형 컴포넌트에서 상태값을 사용 할 수 있다.\n훅이 나오면서 클래스보다는 함수형 컴포넌트로 작성하는 걸 추천한다.</p>\n<h4 id=\"훅-종류\" style=\"position:relative;\"><a href=\"#%ED%9B%85-%EC%A2%85%EB%A5%98\" aria-label=\"훅 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>훅 종류</h4>\n<ul>\n<li>useState</li>\n<li>useEffec</li>\n<li>useContext</li>\n<li>useRef</li>\n<li>useMemo, useCallback</li>\n<li>useReducer</li>\n<li>useImperativeHandle</li>\n<li>useLayoutEffec, useDebugValue</li>\n</ul>\n<h4 id=\"usestate\" style=\"position:relative;\"><a href=\"#usestate\" aria-label=\"usestate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState</h4>\n<p>상태값 변경 함수<br>\n상태값이 변경 되면 리액트는 해당 컴포넌트를 다시 그린다.<br>\n자식 컴포넌트까지 다시 렌더링 된다.<br>\n비동기로 동작, 상태값 변경 요청은 배치로 처리(일괄처리)<br>\n호출 순서가 보장된다. 비동기로 처리되지만 순서대로??</p>\n<h4 id=\"useeffect\" style=\"position:relative;\"><a href=\"#useeffect\" aria-label=\"useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h4>\n<p>부수효과는 함수 실행시 함수 외부의 상태를 변경하는 연산<br>\n렌더링 결과가 실제 돔에 반영된 후 호출,   (비동기로 호출)\n컴포넌트가 사라지기 직전에 마지막으로 호출..<br>\n의존성 배열</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(\n  () =&gt; {\n    getUserApi(userId).then(data =&gt; setUser(data));\n  },\n  [userId],\n);</code></pre></div>\n<p>렌더링시마다 호출되는건 비효율적이기 때문에 두번째 매개변수로 의존성 배열을 추가하면 된다.<br>\n의존성 배열의 값이 변할 경우만 호출된다.   </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return () =&gt; {\n  window.removeEventListener(&#39;resize&#39;, onResize);\n};\n}, []);</code></pre></div>\n<p>반환된 함수는 useEffect(부수효과함수)가 호출되기 직전에 호출되고, 컴포넌트가 사라지기 직전에 호출<br>\n의존성 배열을 빈 배열로 넣을 경우 컴포넌트가 생성될 때만 부수 효과 함수가 호출되고, 컴포넌트가 사라질 때 반환된 함수가 호출   </p>\n<h4 id=\"custom-hook\" style=\"position:relative;\"><a href=\"#custom-hook\" aria-label=\"custom hook permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom Hook</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function useUser(userId) {\n  const [user, setUser] = useState(null);\n  useEffect(() =&gt; {\n    getUserApi(userId).then(data =&gt; setUser(data));\n  }, [userId]);\n  return user;\n}\n\nfunction Profile({ userId }) {\n  const user = useUser(userId);\n}</code></pre></div>\n<p>내부 구현을 숨기면서 사용 편의성을 높인다.</p>\n<h4 id=\"hook-사용시-규칙\" style=\"position:relative;\"><a href=\"#hook-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EA%B7%9C%EC%B9%99\" aria-label=\"hook 사용시 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hook 사용시 규칙</h4>\n<ul>\n<li>하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야 한다.</li>\n<li>함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다.</li>\n</ul>\n<p>리액트는 훅이 사용된 순서를 저장하고 그것을 기반으로 훅을 관리한다.</p>\n<h4 id=\"usecontext\" style=\"position:relative;\"><a href=\"#usecontext\" aria-label=\"usecontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useContext</h4>\n<p>context api의 consumer를 이용하지 않고 부모 컴포넌트에서 전달된 컨텍스트 데이터를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const UserContext = React.createContext();\nconst user = { name: &#39;mike&#39;, age: 23 };\n\nfunction ParentComponent() {\n  return (\n    &lt;UserContext.Provider value={user}&gt;\n      &lt;ChildComponent /&gt;\n    &lt;/UserContext.Provider&gt;\n  )\n}\n\nfunction ChildComponent() {\n  const user = useContext(UserContext);\n  console.log(`user: ${user.name}, ${user.age}`);\n}</code></pre></div>\n<h4 id=\"useref\" style=\"position:relative;\"><a href=\"#useref\" aria-label=\"useref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useRef</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { useRef, useEffect } from &#39;react&#39;;\n\nfucntion TextInput({ inputRef }) {\n  return (\n    &lt;div&gt;\n      &lt;input type=&quot;text&quot; ref={inputRef} /&gt;\n      &lt;button&gt;저장&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n\nfunction From(){\n  const inputRef = useRef();\n  useEffect(() =&gt; {\n    inputRef.current.focus();\n  }, []);\n  return (\n    &lt;div&gt;\n      &lt;TextInput inputRef={inputRef} /&gt;\n      &lt;button onClick={() =&gt; inputRef.current.focus()}&gt;텍스트로 이동&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></div>\n<p>forwardRef를 이용하면 직접 ref 속성값을 처리할 수 있다.</p>\n<p>자식 요소에 접근외에도 중요한 용도로, 컴포넌트 내부에서 렌더링과 무관한 값을 저장할 때 사용된다.   </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const prevAgeRef = useRef(20);\nconst prevAge = prevAgeRef.current;</code></pre></div>\n<h4 id=\"usememo-usecallback\" style=\"position:relative;\"><a href=\"#usememo-usecallback\" aria-label=\"usememo usecallback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo, useCallback</h4>\n<p>이전 값을 기억해서 성능을 최적화하는 용도   </p>\n<ul>\n<li>\n<p>useMemo\n계산량이 많은 함수의 반환값을 재활용</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { runExpensiveJob } from &#39;./util&#39;;\nfunction  MyComponent({ v1, v2 }) {\nconst value = useMemo(() =&gt; runExpensiveJob(v1, v2), [v1, v2]);\nreturn &lt;p&gt;{`value is ${value}`&lt;/p&gt;\n}</code></pre></div>\n<p>의존성 배열이 변경되지 않으면 기존에 계산된 값을 재사용한다.</p>\n</li>\n<li>\n<p>useCallback\n리액트의 렌더링 성능을 위해 제공되는 훅<br>\n속성값이 변할 경우 React.memo를 사용해도 불필요한 렌더링이 발생한다.   </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { saveToServer } from &#39;./api&#39;;\nimport UserEdit from &#39;./UserEdit&#39;;</code></pre></div>\n</li>\n</ul>\n<p>function Profile() {\nconst [name, setName] = useState(”);\nconst [age, setAge] = useState(0);\nreturn(\n<div>\n<p>{<code class=\"language-text\">name is ${name}</code>}</p>\n&#x3C;UserEdit\nonSave={() => saveToServer(name, age)}\nsetName={setName}\nsetAge={setAge}\n/>\n</div>\n);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">렌더링될 때마다 onSave에 새로운 함수가 입력된다.</code></pre></div>\n<p>const onSave = useCallback(() => saveToServer(name, age), [name, age]);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">의존성 배열이 변경되지 않으면 이전에 생성한 함수가 재사용된다.\n\n#### useReducer\n리덕스의 리듀서처럼 관리할 수 있다.   </code></pre></div>\n<p>import React, { useReducer } from ‘react’;</p>\n<p>const INITIAL_STATE = { name: ‘empty’, age: 0 };</p>\n<p>function reducer(state, action) {\nswitch (action.type) {\ncase ‘setName’: return { …state, name: action.name };\ncase ‘setAge’: return { …state, age: action.age };\ndefault: retrun state;\n}\n}</p>\n<p>function Profile() {\nconst [state, dispatch] = useReducer(reducer, INITIAL_STATE);\nreturn (\n<div>\n<p>{<code class=\"language-text\">name is ${name}</code>}</p>\n&#x3C;input\ntype=“text”\nvalue={state.name}\nonChange={e => dispatch({ type: ‘setName’, name: e.currentTarget.value })}\n/>\n</div>\n);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">리덕스의 리듀스 방식으로 작성된 함수\n\n컨텍스트 API와 함께 이벤트 처리 함수 전달</code></pre></div>\n<p>export const ProfileDispatch = REact.createContext(null);</p>\n<p>function Profile() {\nconst [state, dispatch] = useReducer(reducer, INITIAL_STATE);\nreturn (\n<p>{<code class=\"language-text\">name is ${name}</code>}</p>\n&#x3C;ProfileDispatch.Provider value={dispatch}>\n<SomeComponent />\n</ProfileDispatch>\n);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useReducer 훅의 dispatch 함수는 값이 변하지 않는 특징이 있어 불필요하게 렌더링 되는 일은 발생하지 않는다.   \n\n#### useImperativeHandle\n부모 컴퍼넌트에서 접근 가능</code></pre></div>\n<p>useImperativeHandle(ref, () =>({\naddAge: value => setAge(age + value),\ngetNameLength: () => name.length,\n}))</p>\n<p>export default forwardRef(Profile);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#### useLayoutEffec, useDebugValue\n\n- useLayoutEffec\nuseEffec와 비슷하지만 동기로 호출한다.   \n성능상 useEffect를 사용,   \n렌더링 직후 돔 요소의 값을 읽는 경우에는 useLayoutEffect 훅을 사용하는 것이 적합\n\n- useDebugValue\n개발 편의를 위해 제공   \n커스텀 훅의 내부 상태를 관찰할 수 있다.   </code></pre></div>\n<p>function useToggle(initialValue) {\nconst [value, setValue] = useState(initialValue);\nconst onToggle = () => setValue(!value);\nuseDebugValue(value ? ‘on’ : ‘off’);\nreturn [value, onToggle];\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>","fields":{"slug":"/posts/react-hook","tagSlugs":["/tag/front-end/","/tag/react/"]},"frontmatter":{"date":"2020-07-25","description":"리액트 훅 정리","tags":["front-end","react"],"title":"React Hook","socialImage":"/bg_work.jpg"}}},"pageContext":{"slug":"/posts/react-hook"}}}